#!/usr/bin/env python3
# https://en.wikipedia.org/wiki/Chapters_and_verses_of_the_Bible#Chapters

import subprocess
import os
import re

filename = "resources/the-king-james-bible.txt"

SCANNING = 1
BUILDING_CHAPTER = 2
BUILDING_VERSE = 4
BUILDING_REST = 5
FINISHED = 6

def is_number(byte):
    return b'0' <= byte <= b'9'

def is_colon(byte):
    return byte == b':'

def is_new_line(byte):
    return byte == b'\n'

def int2byte(intik):
    return intik.to_bytes(1, byteorder='big')

class Line:
    def __init__(self):
        self.state = SCANNING
        self.buf = b''
        self.next = None
    def accept(self, i, byte):
        if self.state == SCANNING:
            if (is_number(byte)):
                self.state = BUILDING_CHAPTER
                self.start = i 
        if self.state == BUILDING_CHAPTER:
            if (is_number(byte)):
                self.buf = self.buf + byte
            elif is_colon(byte):
                self.buf = self.buf + byte
                self.state = BUILDING_VERSE
                return
            else:
                self.drop()
        if self.state == BUILDING_VERSE:
            if (is_number(byte)):
                self.buf = self.buf + byte
            else:
                last = (self.buf[-1]).to_bytes(1, byteorder='big')
                if is_number(last):
                    self.verse = self.buf
                    self.state = BUILDING_REST
                else:
                    self.drop
        if self.state == BUILDING_REST:
            last = (self.buf[-1]).to_bytes(1, byteorder='big')

            if is_number(byte):
                if self.next is None:
                    self.next = Line()

            if self.next is not None:
                self.next.accept(i, byte)
                if self.next.is_valid():
                    self.end = self.next.start - 1
                    excess_chars = len(self.next.buf)
                    self.buf = self.buf[:-excess_chars]
                    self.state = FINISHED

            if is_new_line(byte) and is_new_line(last):                
                self.state = FINISHED
                self.end = i
            else:
                self.buf = self.buf + byte

    def drop(self):
        self.state = SCANNING
        self.buf = b''

    def is_finished(self):
        return self.state == FINISHED
    
    def is_valid(self):
        return self.state == BUILDING_REST

def from_file_byte_yielder(filename):
    with open(filename, "rb") as f:
        while 1: 
            byte = f.read(1)
            if byte == b"":
                yield b""
            yield byte

def line_yielder(byte_yielder):
    i = 0
    line = Line()
    
    for byte in byte_yielder:
        line.accept(i, byte)

        if line.is_finished():    
            yield line

            next = line.next
            if next is None:
                line = Line()
            else:
                line = next
            
        if byte == b"":
            return
        i = i + 1

i = 0
for l in line_yielder(from_file_byte_yielder(filename)):
    if i > 80:
        break
    print(f"{l.verse} {l.start}-{l.end} {l.buf}")
    i = i + 1

# start = 0
# end = 0
# cursor = 0
# gaps = []

# for line in line_yielder(from_file_byte_yielder(filename)):
#     if line.start - 1 > cursor:
#         gap = (cursor, line.start - 1)
#         gaps.append(gap)
#     cursor = line.end

# print(gaps)